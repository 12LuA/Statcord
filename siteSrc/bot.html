<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="description" content="View statistics of a Discord bot.">
		<title>DisStat - View statistics of a bot</title>
		<link rel="shortcut icon" href="./assets/icon.png">

		<link rel="preconnect" href="https://disstat-api.tomatenkuchen.com/" crossorigin>
		<link rel="dns-prefetch" href="https://disstat-api.tomatenkuchen.com/">

		<script src="./assets/main.js"></script>
		<script src="./assets/api.js"></script>
		<link rel="stylesheet" href="./assets/style.css">

		<script
			src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js" integrity="sha512-SIMGYRUjwY8+gKg7nn9EItdD8LCADSDfJNutF9TPrvEo86sQmFMh6MyralfIyhADlajSxqc7G0gs7+MwWF/ogQ=="
			crossorigin="anonymous" referrerpolicy="no-referrer"
		></script>
	</head>
	<body onload="setupFilters()">
		<global-navbar></global-navbar>

		<main id="content">
			<h1 id="loading-text">Loading...</h1>
			<a id="edit-bot-target"><button type="button" id="edit-bot" hidden>Edit bot</button></a>

			<div id="setup" hidden>
				<h2>Your bot has been created successfully!</h2>

				<p>Here are some tips to get started:</p>

				<ul>
					<li>
						<b><a href="./setup">Setup guide</a></b>: Use the API or a package to post stats using the API key <input id="botapikey" size="27" onfocus="this.select()" readonly>
					</li>
					<li><b><a id="edit-bot-target2">Settings</a></b>: Configure settings & charts of your bot</li>
				</ul>
			</div>

			<div id="statcord" hidden>
				<h2>Your bot has data on Statcord!</h2>

				<p>
					Your bot was registered on Statcord, so we might be able to import data from there.
					<br>
					This cannot overwrite any data on DisStat as the last time Statcord successfully processed data was on 2023-04-29.
					<br>
					Be aware that this will cause a jump in the charts.
				</p>

				<br>
				<button type="button" class="red" onclick="statcordImport('importStarted')">Import</button>
				<button type="button" class="gray" onclick="statcordImport('dismissed')">Dismiss</button>
			</div>

			<div id="cards-container"></div>

			<details id="filter-container">
				<summary>Filters</summary>

				<label for="start-time">Start time:</label>
				<input type="datetime-local" id="start-time" min="2023-07-17T00:00" value="2023-07-17T00:00">

				<br>
				<label for="end-time">End time:</label>
				<input type="datetime-local" id="end-time" min="2023-07-17T00:00">

				<br>
				<label for="data-points">Amount of data points:</label>
				<input type="number" id="data-points" min="2" max="1000" value="90">

				<br>
				<button type="button" class="green" onclick="load()">Filter</button>
			</details>
			<div id="charts"></div>
		</main>
		<script>
			function setupFilters() {
				const curDate = new Date(new Date().setSeconds(0))
				document.getElementById("start-time").max = curDate.toISOString().split(".")[0]
				document.getElementById("end-time").value = curDate.toISOString().split(".")[0]
				document.getElementById("end-time").max = new Date(Date.now() + 1000 * 60 * 60).toISOString().split(".")[0]
			}
			setTimeout(setupFilters, 2500)

			function formatBytes(bytes, decimals = 2) {
				if (bytes == 0) return "0 Bytes"

				const k = 1024
				const dm = decimals < 0 ? 0 : decimals
				const sizes = ["bytes", "KiB", "MiB", "GiB", "TiB", "PiB"]

				const i = Math.floor(Math.log(bytes) / Math.log(k))
				return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + " " + sizes[i]
			}

			async function load() {
				if (!new URLSearchParams(location.search).has("id")) return location.href = "/"

				if (new URLSearchParams(location.search).has("setup")) getKey()
				bot = await getBot()
				if (!bot.username) return document.getElementById("content").innerHTML = "<h1>Bot not found.</h1>"

				document.getElementById("loading-text").innerHTML = "Information about <strong>" + encode(bot.username) + "</strong>"
				document.querySelector("title").innerText = "DisStat - View statistics of " + encode(bot.username)

				if (bot.isOwner) {
					document.getElementById("edit-bot").removeAttribute("hidden")
					document.getElementById("edit-bot-target").href = "/bot/edit?id=" + encode(bot.botId)
					document.getElementById("edit-bot-target2").href = "/bot/edit?id=" + encode(bot.botId)

					if (new URLSearchParams(location.search).has("setup")) document.getElementById("setup").removeAttribute("hidden")
					if (bot.statcordVisible) document.getElementById("statcord").removeAttribute("hidden")
				}

				if (bot.charts.length == 0) document.getElementById("charts").innerHTML = "<h2>No charts available.</h2>"
				else {
					Object.values(Chart.instances).forEach(chart => chart.destroy())
					document.getElementById("charts").innerHTML = ""

					bot.charts.forEach(chart => {
						const parentElement = document.createElement("div")

						const chartElement = document.createElement("canvas")
						chartElement.setAttribute("id", chart.name)
						chartElement.setAttribute("width", "570")
						chartElement.setAttribute("height", "330")
						chartElement.setAttribute("aria-label", "Chart for " + chart.name)
						chartElement.setAttribute("role", "img")

						parentElement.appendChild(chartElement)
						document.getElementById("charts").appendChild(parentElement)

						new Chart(chartElement.getContext("2d"), {
							type: chart.type || "line",
							data: {
								labels: chart.labels,
								datasets: [{
									label: chart.name,
									data: chart.data,
									borderColor: chart.borderColor,
									backgroundColor: chart.borderColor
								}]
							},
							options: {
								scales: {
									y: {
										ticks: {
											callback: value => chart.format == "byte" ? formatBytes(value) : (chart.format == "%" ? value + "%" : value.toLocaleString())
										},
										beginAtZero: chart.format == "%"
									}
								},
								layout: {
									padding: 13
								},
								maintainAspectRatio: false,
								plugins: {
									legend: {
										display: false
									},
									title: {
										display: true,
										text: chart.name
									},
									tooltip: {
										callbacks: {
											label: context => {
												let label = context.dataset.label + ": "

												if (context.parsed.y !== null) {
													if (chart.format == "byte") label += formatBytes(context.parsed.y)
													else if (chart.format == "%") label += context.parsed.y + "%"
													else label += context.parsed.y.toLocaleString()
												}
												return label
											}
										}
									}
								}
							}
						})
					})
				}

				const cards = [
					"<div>" +
						"<span>Last stats posted to API</span>" +
						"<p>" + (bot.lastStats ? new Date(bot.lastStats).toLocaleString(navigator.language, {timezone: new Intl.DateTimeFormat().resolvedOptions().timeZone}) : "Never") + "</p>" +
					"</div>",
					"<div title='Calculates the uptime based on the actual amount of posts (" + bot.actualPosts + ") divided through the expected amount of posts (" + bot.expectedPosts + ")'>" +
						"<span>Calculated uptime</span>" +
						"<p>" + (bot.actualPosts / bot.expectedPosts * 100).toFixed(2) + "%</p>" +
					"</div>"
				]

				if (bot.customData && bot.customData.perType) {
					Object.keys(bot.customData.perType).forEach(type => {
						cards.push(
							"<div>" +
								"<span>Custom graph posts for <u>" + type + "</u></span>" +
								"<p>" + bot.customData.perType[type] + "</p>" +
							"</div>"
						)
					})
				}

				document.getElementById("cards-container").innerHTML = cards.join("")
			}
			load()
		</script>

		<script
			src="https://cdn.jsdelivr.net/npm/ionicons@7.2.0/dist/ionicons/ionicons.esm.js" integrity="sha384-zM76IY+3I2OTF49JR8mjLWUeugc/Q9wVzLMiSITfvgmdy8nQtAhci8m8IsdnTl3q"
			type="module" crossorigin="anonymous" data-no-instant
		></script>
		<script src="./assets/instantclick.min.js" data-no-instant></script>
	</body>
</html>
